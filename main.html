<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.gridMaterial.min.js"></script>
  <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>

  <link rel="stylesheet" type="text/css" href="gos_main.css">
  <link rel="stylesheet" type="text/css" href="nav_bar.css">
  <link rel="preload" href="http://localhost:8080/maps/sewer_full.png" as="image">
  <link rel="preload" href="http://localhost:8080/maps/sewer_mask.png" as="image">


  <title>Graveyard of Ships</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Babylon.js Scene</title>



</head>

<body>

<canvas id="renderCanvas" touch-action="none"></canvas>
<button id="visibilityToggle" class="button skew-right">Toggle visibility</button>

<div class="modal">
  <div class="modal-content">
    <span class="close-button">Ã—</span>
    <div id="modal-iframe">This is extremely nice BOX! <br> <p style="color:green">No problems with CSS styling.</p></div>
  </div>
</div>

<script>
  var modal = document.querySelector(".modal");
//  var trigger = document.querySelector(".trigger");
  var closeButton = document.querySelector(".close-button");

  function toggleModal() {
    modal.classList.toggle("show-modal");

  }

  function windowOnClick(event) {
    if (event.target === modal) {
      toggleModal();
    }
  }

 // trigger.addEventListener("click", toggleModal);
  closeButton.addEventListener("click", toggleModal);
  window.addEventListener("click", windowOnClick);
</script>

<script>
  /**
   *This map saves references to the individual elements which are saved as separate html elements that refer to elements of the map.
   */

  //This is a list of all meshes used in the map
  //Each mesh is linked to an html page describing it
  var meshContent = {
    varutha_ship: 'locations/varutha_ship.html',
    natural_order: 'locations/natural_order.html',
    pirate_base: 'locations/pirate_base.html',
    metal_crusher_nest: 'locations/metal_crusher_nest.html',
    Korpus: 'locations/pirate_outpost.html',
    sleeping_beauty: 'locations/sleeping_beauty.html',
    bumblebee: 'locations/bumblebee.html',
    damians_ship: 'locations/damians_ship.html'
  }

  // Global variables for cameras
  let universalCamera;
  let arcRotateCamera;
  let lastSelectedMesh;


  //The top level object for using Babylon used to display the map (i.e., the scene)
  const canvas = document.getElementById("renderCanvas"); // Get the canvas element
  var engine = new BABYLON.Engine(canvas, true, {
    preserveDrawingBuffer: true,
    stencil: true,
    disableWebGL2Support: false
  });

  document.addEventListener('keydown', function(event) {
    if (event.key === 'c' || event.key === 'C') {
      switchCamera(scene, universalCamera, arcRotateCamera);
    }
  });

  /*
      const varutha_ship_task = assetsManager.addMeshTask("practice task", "", "http://localhost:8080/models/","varutha_cone_ship_join.glb");

    varutha_ship_task.onSuccess = function (task) {

      let varutha_ship = task.loadedMeshes[0];
      varutha_ship.computeWorldMatrix(true);

      varutha_ship.name = "varutha_ship";
      console.log("varutha_ship:", varutha_ship)
      // var boundingInfo = mesh.getBoundingInfo();
      // var height = boundingInfo.maximum.y - boundingInfo.minimum.y;
      //
      // var desiredHeight = 170;// Height from Step 3
      // var scaleFactor = desiredHeight / height;
      //
      // console.log("scale factor:", scaleFactor)
      //
      // mesh.scaling = new BABYLON.Vector3(scaleFactor, scaleFactor, scaleFactor);

      varutha_ship.position = new BABYLON.Vector3(0, -50, 0);

      console.log("Rotation: " + varutha_ship.rotation);

      // Apply rotation
      varutha_ship.rotation.y = 30 * (Math.PI / 180);
      varutha_ship.rotation.x = 30 * (Math.PI / 180);
      varutha_ship.rotation.z = 30 * (Math.PI / 180);

      // Example rotation values, Y, X, Z
      var alpha = 15 * (Math.PI / 180);
      var beta = -15 * (Math.PI / 180);
      var gamma = 0 * (Math.PI / 180);

      // Create a quaternion from Euler angles
      var quaternion = BABYLON.Quaternion.FromEulerAngles(beta, alpha, gamma);

      // Assign the quaternion to the mesh
      varutha_ship.rotationQuaternion = quaternion;

      console.log("Rotation after setting: " + varutha_ship.rotation);

      scene.addMesh(varutha_ship);
      meshList.push(varutha_ship);

      console.log("Set position");
   //   varutha_ship.freezeWorldMatrix();
    }
   */// Assume assetsManager is already set uplet loadedMeshes = {}; // Object to store the original meshes keyed by their names
  let loadedMeshes = {};
  function loadModels(scene, assetsManager, modelNames) {
    modelNames.forEach((modelName) => {
      let task = assetsManager.addMeshTask(modelName + " task", "", "http://localhost:8080/models/", modelName + ".glb");

      task.onSuccess = function (task) {
        let meshesWithGeometry = task.loadedMeshes.filter(mesh => mesh.getTotalVertices() > 0);
        if (meshesWithGeometry.length > 0) {
          // Merge meshes with geometry into a single mesh
          let mergedMesh = BABYLON.Mesh.MergeMeshes(meshesWithGeometry, true, true, undefined, false, true);
          if (mergedMesh) {
            mergedMesh.name = `${modelName}-merged`;
            loadedMeshes[modelName] = mergedMesh;
            console.log(`Loaded and merged ${modelName}:`, mergedMesh);
          } else {
            console.warn(`Could not merge meshes for ${modelName}`);
          }
        } else {
          console.warn(`No meshes with geometry found for ${modelName}`);
        }
      };

      task.onError = function (task, message, exception) {
        console.error(`Failed to load ${modelName}: ${message}`, exception);
      };
    });
  }



  function createInstanceFromModel(modelName, position) {
    if (!loadedMeshes[modelName]) {
      console.error("Model not loaded:", modelName);
      return;
    }

    let originalMesh = loadedMeshes[modelName];
    console.log("Creating instance from model:", modelName);
    let instance = originalMesh.createInstance(modelName + " instance");

    // Set a random position, scaling, and rotation for the instance
    //instance.position = getRandomPositionInsideSphere(center, radius);
    instance.position = position;
    instance.scaling = new BABYLON.Vector3(5, 5, 5);
    instance.rotationQuaternion = BABYLON.Quaternion.RotationYawPitchRoll(
            Math.random() * 2 * Math.PI, // Random yaw
            Math.random() * 2 * Math.PI, // Random pitch
            Math.random() * 2 * Math.PI  // Random roll
    );
    //Freeze world matrix
    instance.freezeWorldMatrix();
  }

  function createScene(onAssetsLoaded) {
    let scene = new BABYLON.Scene(engine);
    let assetsManager = new BABYLON.AssetsManager(scene);

    createUniversalCamera(scene, canvas);
    createArcRotateCamera(scene, canvas);
    scene.activeCamera = universalCamera;

    let light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);
    light.intensity = 1; // Increase intensity (default is 1)


     createSkyBox(scene, assetsManager);
    //  createSphericalSkyBox(scene, assetsManager);
    // Load the assets
    //Create empty list of meshes
    const meshList = [];
    const edgeList = [];


    const bumblebee_task = assetsManager.addMeshTask("bumblebee task", "", "http://localhost:8080/models/","bumblebee.glb");

    bumblebee_task.onSuccess = function (task) {

      let bumblebee = task.loadedMeshes[0];
      bumblebee.computeWorldMatrix(true);

      bumblebee.name = "bumblebee";
      console.log("bumblebee:", bumblebee)
      // var boundingInfo = mesh.getBoundingInfo();
      // var height = boundingInfo.maximum.y - boundingInfo.minimum.y;
      //
      // var desiredHeight = 170;// Height from Step 3
      // var scaleFactor = desiredHeight / height;
      //
      // console.log("scale factor:", scaleFactor)
      //
      // mesh.scaling = new BABYLON.Vector3(scaleFactor, scaleFactor, scaleFactor);

      bumblebee.position = new BABYLON.Vector3(40, 0, -550);

      console.log("Rotation: " + bumblebee.rotation);

      // Apply rotation
      // bumblebee.rotation.y = 30 * (Math.PI / 180);
      // bumblebee.rotation.x = 30 * (Math.PI / 180);
      // bumblebee.rotation.z = 30 * (Math.PI / 180);

      // Example rotation values, Y, X, Z
      var alpha = 170 * (Math.PI / 180);
      var beta = -15 * (Math.PI / 180);
      var gamma = 25 * (Math.PI / 180); // up down

      // Create a quaternion from Euler angles
      var quaternion = BABYLON.Quaternion.FromEulerAngles(beta, alpha, gamma);

      // Assign the quaternion to the mesh
      bumblebee.rotationQuaternion = quaternion;

      console.log("Rotation after setting: " + bumblebee.rotation);

      scene.addMesh(bumblebee);
      meshList.push(bumblebee);

      console.log("Set position");
      //   varutha_ship.freezeWorldMatrix();
    }

    const damian_task = assetsManager.addMeshTask("bumblebee task", "", "http://localhost:8080/models/","damian_ship.glb");

    damian_task.onSuccess = function (task) {

      let damians_ship = task.loadedMeshes[0];
      damians_ship.computeWorldMatrix(true);

      damians_ship.name = "damians_ship";
      console.log("damians_ship:", damians_ship)
      // var boundingInfo = mesh.getBoundingInfo();
      // var height = boundingInfo.maximum.y - boundingInfo.minimum.y;
      //
      // var desiredHeight = 170;// Height from Step 3
      // var scaleFactor = desiredHeight / height;
      //
      // console.log("scale factor:", scaleFactor)
      //
      // mesh.scaling = new BABYLON.Vector3(scaleFactor, scaleFactor, scaleFactor);

      damians_ship.position = new BABYLON.Vector3(-150, -60, -450);

      console.log("Rotation: " + damians_ship.rotation);

      // Apply rotation
      // bumblebee.rotation.y = 30 * (Math.PI / 180);
      // bumblebee.rotation.x = 30 * (Math.PI / 180);
      // bumblebee.rotation.z = 30 * (Math.PI / 180);

      // Example rotation values, Y, X, Z
      var alpha = 80 * (Math.PI / 180);
      var beta = -30 * (Math.PI / 180);
      var gamma = 50 * (Math.PI / 180); // up down

      // Create a quaternion from Euler angles
      var quaternion = BABYLON.Quaternion.FromEulerAngles(beta, alpha, gamma);

      // Assign the quaternion to the mesh
      damians_ship.rotationQuaternion = quaternion;

      console.log("Rotation after setting: " + damians_ship.rotation);

      scene.addMesh(damians_ship);
      meshList.push(damians_ship);

      console.log("Set position");
      //   varutha_ship.freezeWorldMatrix();
    }


    const cargoMesh = assetsManager.addMeshTask("cargo task", "", "http://localhost:8080/models/","cargo.glb");

    cargoMesh.onSuccess = function (task) {
      let mesh = task.loadedMeshes[0];
      mesh.setParent(null);
      console.log("Applying zoom to: ");
      scene.addMesh(mesh);
      mesh.position = new BABYLON.Vector3(20, -50, -350);
      console.log("Set position");
      mesh.name = "pirate_outpost";
      // Apply scale
      mesh.scaling = new BABYLON.Vector3(7, 7, 7);

      // Apply rotation
      mesh.rotation.y = -45 * (Math.PI / 180);
      mesh.rotation.x = 100 * (Math.PI / 180);
      mesh.rotation.z = 30 * (Math.PI / 180);

      // Example rotation values, Y, X, Z
      var alpha = 175 * (Math.PI / 180);
      var beta =  -10 * (Math.PI / 180);
      var gamma = 5 * (Math.PI / 180);

      // Create a quaternion from Euler angles
      var quaternion = BABYLON.Quaternion.FromEulerAngles(beta, alpha, gamma);

      // Assign the quaternion to the mesh
      mesh.rotationQuaternion = quaternion;
      meshList.push(mesh);


      // Optionally freeze the world matrix after all transformations are applied
  //    mesh.freezeWorldMatrix();
    };

    cargoMesh.onError = function (task, message, exception) {
      console.log(message, exception);
    };


    const varutha_ship_task = assetsManager.addMeshTask("practice task", "", "http://localhost:8080/models/","varutha_cone_ship_join.glb");

    varutha_ship_task.onSuccess = function (task) {

      let varutha_ship = task.loadedMeshes[0];
      varutha_ship.computeWorldMatrix(true);

      varutha_ship.name = "varutha_ship";
      console.log("varutha_ship:", varutha_ship)
      // var boundingInfo = mesh.getBoundingInfo();
      // var height = boundingInfo.maximum.y - boundingInfo.minimum.y;
      //
      // var desiredHeight = 170;// Height from Step 3
      // var scaleFactor = desiredHeight / height;
      //
      // console.log("scale factor:", scaleFactor)
      //
      // mesh.scaling = new BABYLON.Vector3(scaleFactor, scaleFactor, scaleFactor);

      varutha_ship.position = new BABYLON.Vector3(0, -50, 0);

      console.log("Rotation: " + varutha_ship.rotation);

      // Apply rotation
      varutha_ship.rotation.y = 30 * (Math.PI / 180);
      varutha_ship.rotation.x = 30 * (Math.PI / 180);
      varutha_ship.rotation.z = 30 * (Math.PI / 180);

      // Example rotation values, Y, X, Z
      var alpha = 15 * (Math.PI / 180);
      var beta = -15 * (Math.PI / 180);
      var gamma = 0 * (Math.PI / 180);

      // Create a quaternion from Euler angles
      var quaternion = BABYLON.Quaternion.FromEulerAngles(beta, alpha, gamma);

      // Assign the quaternion to the mesh
      varutha_ship.rotationQuaternion = quaternion;

      console.log("Rotation after setting: " + varutha_ship.rotation);

      scene.addMesh(varutha_ship);
      meshList.push(varutha_ship);

      console.log("Set position");
   //   varutha_ship.freezeWorldMatrix();
    }

    varutha_ship_task.onError = function (task, message, exception) {
      console.log(message, exception);
    };

    const sleeping_beauty_task = assetsManager.addMeshTask("practice task", "", "http://localhost:8080/models/","sleeping_beauty.glb");

   sleeping_beauty_task.onSuccess = function (task) {

      let sleeping_beauty = task.loadedMeshes[0];
      sleeping_beauty.computeWorldMatrix(true);

      sleeping_beauty.name = "sleeping_beauty";
      console.log("Sleeping beauty:", sleeping_beauty)
      // var boundingInfo = mesh.getBoundingInfo();
      // var height = boundingInfo.maximum.y - boundingInfo.minimum.y;
      //
      // var desiredHeight = 170;// Height from Step 3
      // var scaleFactor = desiredHeight / height;
      //
      // console.log("scale factor:", scaleFactor)
      //
      // mesh.scaling = new BABYLON.Vector3(scaleFactor, scaleFactor, scaleFactor);

      sleeping_beauty.position = new BABYLON.Vector3(200, 100, 150);

      console.log("Rotation: " + sleeping_beauty.rotation);

      // Apply rotation
      sleeping_beauty.rotation.y = 30 * (Math.PI / 180);
      sleeping_beauty.rotation.x = 30 * (Math.PI / 180);
      sleeping_beauty.rotation.z = 30 * (Math.PI / 180);

      // Example rotation values, Y, X, Z
      var alpha = -45 * (Math.PI / 180);
      var beta = -10 * (Math.PI / 180);
      var gamma = 60 * (Math.PI / 180);

      // Create a quaternion from Euler angles
      var quaternion = BABYLON.Quaternion.FromEulerAngles(beta, alpha, gamma);

      // Assign the quaternion to the mesh
      sleeping_beauty.rotationQuaternion = quaternion;

      console.log("Rotation after setting: " + sleeping_beauty.rotation);

      scene.addMesh(sleeping_beauty);
      meshList.push(sleeping_beauty);

      console.log("Set position");
      //   varutha_ship.freezeWorldMatrix();
    }

    varutha_ship_task.onError = function (task, message, exception) {
      console.log(message, exception);
    };

    const pirate_base_task = assetsManager.addMeshTask("practice task", "", "http://localhost:8080/models/","pirate_base.glb");

    pirate_base_task.onSuccess = function (task) {

      let pirate_base = task.loadedMeshes[0];
      pirate_base.computeWorldMatrix(true);

      pirate_base.name = "pirate_base";
      console.log("pirate_base:", pirate_base)
      // var boundingInfo = mesh.getBoundingInfo();
      // var height = boundingInfo.maximum.y - boundingInfo.minimum.y;
      //
      // var desiredHeight = 170;// Height from Step 3
      // var scaleFactor = desiredHeight / height;
      //
      // console.log("scale factor:", scaleFactor)
      //
      // mesh.scaling = new BABYLON.Vector3(scaleFactor, scaleFactor, scaleFactor);

      pirate_base.position = new BABYLON.Vector3(400, 100, -170);

      console.log("Rotation: " + pirate_base.rotation);

      // Apply rotation
      // pirate_base.rotation.y = 30 * (Math.PI / 180);
      // pirate_base.rotation.x = 30 * (Math.PI / 180);
      // pirate_base.rotation.z = 30 * (Math.PI / 180);

      // Example rotation values, Y, X, Z
      // var alpha = -90 * (Math.PI / 180);
      // var beta = 0 * (Math.PI / 180);
      // var gamma = 0 * (Math.PI / 180);
      //
      // // Create a quaternion from Euler angles
      // var quaternion = BABYLON.Quaternion.FromEulerAngles(beta, alpha, gamma);
      //
      // // Assign the quaternion to the mesh
      // pirate_base.rotationQuaternion = quaternion;

      // console.log("Rotation after setting: " + pirate_base.rotation);

      scene.addMesh(pirate_base);
      meshList.push(pirate_base);

      console.log("Set position");
      //   varutha_ship.freezeWorldMatrix();
    }

    varutha_ship_task.onError = function (task, message, exception) {
      console.log(message, exception);
    };

    console.log("Loading debris models....")
    loadModels(scene, assetsManager, ['debris1']);


    // //Starting point
    //  const box = BABYLON.MeshBuilder.CreateSphere("bumblebee", {diameter: 50}, scene);
    //  box.name = "bumblebee";
    //   // Create a new material with a red diffuse color
    //   //var red_material = new BABYLON.StandardMaterial("redMaterial", scene);
    //   var red_material = new BABYLON.GridMaterial("groundMaterial", scene);
    //   red_material.diffuseColor = new BABYLON.Color3(1, 0, 0); // set to red
    //   red_material.specularColor = new BABYLON.Color3(0, 0, 0);
    //   // Assume that "mesh" is the mesh object that you want to color
    //   box.material = red_material;
    //   box.position = new BABYLON.Vector3(40, 0, -500);
    //   scene.addMesh(box);
    //   meshList.push(box);

    //Pirate outpost
    // const box1 = BABYLON.MeshBuilder.CreateSphere("pirate_outpost", {diameter: 10}, scene);
    // // Create a new material with a red diffuse color
    // var grey_material = new BABYLON.StandardMaterial("redMaterial", scene);
    // grey_material.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2); // set to red
    // grey_material.specularColor = new BABYLON.Color3(0, 0, 0);
    // // Assume that "mesh" is the mesh object that you want to color
    // box1.material = grey_material;
    // box1.position = new BABYLON.Vector3(20, -50, -350);
    // scene.addMesh(box1);
    // meshList.push(box1);
    // edgeList.push([box.position, box1.position]);

    //metal crusher nest
    const box2 = BABYLON.MeshBuilder.CreateSphere("metal_crusher_nest", {diameter: 150}, scene);
    box2.name = "metal_crusher_nest";
    // Create a new material with a red diffuse color
    var dark_material = new BABYLON.StandardMaterial("redMaterial", scene);
    dark_material.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1); // set to red
    dark_material.specularColor = new BABYLON.Color3(0, 0, 0);
    dark_material.alpha = 1;
    dark_material.depth_write = true;
    // Assume that "mesh" is the mesh object that you want to color
    box2.material = dark_material;
    box2.position = new BABYLON.Vector3(-350, -150, 20);
    scene.addMesh(box2);
    meshList.push(box2);

    //Pirate hideout
    // const box3 = BABYLON.MeshBuilder.CreateSphere("pirate_base", {diameter: 100}, scene);
    // // Create a new material with a red diffuse color
    // // Assume that "mesh" is the mesh object that you want to color
    // box3.material = dark_material;
    // box3.name = "pirate_base";
    // box3.position = new BABYLON.Vector3(200, 100, -170);
    // scene.addMesh(box3);
    // meshList.push(box3);

//     var box4 = BABYLON.MeshBuilder.CreateBox("sleeping_beauty", {
//       width: 25,  // Set the width of the box
//       height: 40, // Set the height of the box
//       depth: 120  // Set the depth (length) of the box
//     }, scene);
// // Create a new standard material
//     box4.name = "sleeping_beauty";
//     var sleep_beaut_material = new BABYLON.StandardMaterial("myMaterial", scene);

// Set the diffuse color to a light grey with a tint of red
// Note: BABYLON.Color3 takes RGB values between 0 and 1
//     var redTint = 0.8; // Adjust for more or less red
//     var greyBase = 0.8; // Light grey base
//     sleep_beaut_material.diffuseColor = new BABYLON.Color3(redTint, greyBase * 0.9, greyBase * 0.9); // Slightly red tinted light grey
//     box4.material = sleep_beaut_material
//     box4.specularColor = new BABYLON.Color3(0, 0, 0);
//     box4.position = new BABYLON.Vector3(200, 100, 150);
//     box4.rotation.y = -45 * (Math.PI / 180); // Rotates the box 45 degrees around the Y axis
//
// // If you want to rotate around other axes, you can similarly adjust rotation.x or rotation.z
//     box4.rotation.x = 10 * (Math.PI / 180); // Rotates the box 30 degrees around the X axis
//     //box4.rotation.z = 60 * (Math.PI / 180); // Rotates the box 60 degrees around the Z axis
//     scene.addMesh(box4)
//     meshList.push(box4)




    var ufoDome = BABYLON.MeshBuilder.CreateSphere("ufo", {diameter: 260, slice: 0.5}, scene); // This creates an ellipsoid
    //ufoDome.scaling.y = 0.3; // Flatten the ellipsoid to make it look more like a UFO
    var ufo = BABYLON.MeshBuilder.CreateSphere("ufoDome", {diameter:340, diameterX: 340, diameterY: 40}, scene);
    ufo.name = "natural_order";
    ufoDome.position.y = 0.2; // Adjust position to sit on top of the main body
    var light_material = new BABYLON.StandardMaterial("lightMaterial",scene);
    var green_material = new BABYLON.StandardMaterial("lgreenMaterial",scene);
    light_material.diffuseColor = new BABYLON.Color3(0.8,0.8,0.8)
    light_material.specularColor = new BABYLON.Color3(0, 0, 0);
    green_material.diffuseColor = new BABYLON.Color3(0.0,0.8,0.2)
    green_material.specularColor = new BABYLON.Color3(0, 0, 0);
    ufo.material = light_material;
    ufoDome.material = green_material;
    ufo.position = new BABYLON.Vector3(-300,100,350);
    ufoDome.position = new BABYLON.Vector3(-300,100,350);
    scene.addMesh(ufo)
    scene.addMesh(ufoDome)
    meshList.push(ufo)
    meshList.push(ufoDome)

    // const box2 = BABYLON.MeshBuilder.CreateBox("ship2", {size: 1}, scene);
      // box2.position = new BABYLON.Vector3(0, 0, 5);
      // scene.addMesh(box2);
      // meshList.push(box2);


    //   const centralShip = BABYLON.MeshBuilder.CreateCylinder("cone", {
    //     height: 170,
    //     diameterTop: 0,
    //     diameterBottom: 140,
    //     tessellation: 64 // Defines the number of sides. Increase for a smoother surface.
    //   }, scene);
    //   centralShip.position = new BABYLON.Vector3(0, -50, 0);
    // var coneMaterial = new BABYLON.StandardMaterial("coneMaterial", scene);
    // coneMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7); // Light grey as the base color
    // coneMaterial.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8); // Bright white for specular highlights
    // coneMaterial.specularPower = 50; // Adjust for shininess - lower value makes it more "shiny"
    // coneMaterial.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1); // Slightly emissive to simulate metallic sheen
    //
    // centralShip.material = coneMaterial;
    // scene.addMesh(centralShip)
    // meshList.push(centralShip)

    //Iterate through mesh list and assign every mesh renderingGroup 1
    // for (var i = 0; i < meshList.length; i++) {
    //   meshList[i].renderingGroupId = 1;
    // }

  /*Sun, taken from: https://www.babylonjs-playground.com/#YSQLI3#0 (11.03.2024)s
  */


    /**
     * Create non-interactive meshes
     */

   // createDebris(scene,assetsManager)
// Example usage:
// Load the models first

  //  loadModels(scene, assetsManager, ['debris1', 'debris2', 'debris3', 'debris4'], (loadedMeshesCount) => {
      // Once models are loaded, create instances


    // Create a particle system
    var surfaceParticles = new BABYLON.ParticleSystem("surfaceParticles", 1600, scene);
    var flareParticles = new BABYLON.ParticleSystem("flareParticles", 20, scene);

    // Texture of each particle
    surfaceParticles.particleTexture = new BABYLON.Texture("https://raw.githubusercontent.com/PatrickRyanMS/BabylonJStextures/master/ParticleSystems/Sun/T_SunSurface.png", scene);
    flareParticles.particleTexture = new BABYLON.Texture("https://raw.githubusercontent.com/PatrickRyanMS/BabylonJStextures/master/ParticleSystems/Sun/T_SunFlare.png", scene);



    var scaleFactor = 500 / 2.01;

    // Create core sphere
    var coreSphere = BABYLON.MeshBuilder.CreateSphere("coreSphere", {diameter: 500, segments: 64}, scene);
    coreSphere.position = new BABYLON.Vector3(1250, 1250,1250);

    // Create core material
    var coreMat = new BABYLON.StandardMaterial("coreMat", scene)
    coreMat.emissiveColor = new BABYLON.Color3(0.3773, 0.0930, 0.0266);

    // Assign core material to sphere
    coreSphere.material = coreMat;

    // Pre-warm
    surfaceParticles.preWarmStepOffset = 10;
    surfaceParticles.preWarmCycles = 100;

    flareParticles.preWarmStepOffset = 10;
    flareParticles.preWarmCycles = 100;

    // Initial rotation
    surfaceParticles.minInitialRotation = -2 * Math.PI;
    surfaceParticles.maxInitialRotation = 2 * Math.PI;

    flareParticles.minInitialRotation = -2 * Math.PI;
    flareParticles.maxInitialRotation = 2 * Math.PI;

    // Where the sun particles come from
    var sunEmitter = new BABYLON.SphereParticleEmitter();
    sunEmitter.radius = scaleFactor;
    sunEmitter.radiusRange = 0; // emit only from shape surface


    // Assign particles to emitters
    surfaceParticles.emitter = coreSphere; // the starting object, the emitter
    surfaceParticles.particleEmitterType = sunEmitter;

    flareParticles.emitter = coreSphere; // the starting object, the emitter
    flareParticles.particleEmitterType = sunEmitter;

    // Color gradient over time
    surfaceParticles.addColorGradient(0, new BABYLON.Color4(0.8509, 0.4784, 0.1019, 0.0));
    surfaceParticles.addColorGradient(0.4, new BABYLON.Color4(0.6259, 0.3056, 0.0619, 0.5));
    surfaceParticles.addColorGradient(0.5, new BABYLON.Color4(0.6039, 0.2887, 0.0579, 0.5));
    surfaceParticles.addColorGradient(1.0, new BABYLON.Color4(0.3207, 0.0713, 0.0075, 0.0));

    flareParticles.addColorGradient(0, new BABYLON.Color4(1, 0.9612, 0.5141, 0.0));
    flareParticles.addColorGradient(0.25, new BABYLON.Color4(0.9058, 0.7152, 0.3825, 1.0));
    flareParticles.addColorGradient(1.0, new BABYLON.Color4(0.6320, 0.0, 0.0, 0.0));

    // Size of each particle (random between...
    surfaceParticles.minSize = 0.4 * scaleFactor;
    surfaceParticles.maxSize = 0.7 * scaleFactor;

    flareParticles.minScaleX = 0.5 * scaleFactor;
    flareParticles.minScaleY = 0.5 * scaleFactor;
    flareParticles.maxScaleX= scaleFactor;
    flareParticles.maxScaleY = scaleFactor;

    // Size over lifetime
    flareParticles.addSizeGradient(0, 0);
    flareParticles.addSizeGradient(1, 1);

    // Life time of each particle (random between...
    surfaceParticles.minLifeTime = 8.0;
    surfaceParticles.maxLifeTime = 8.0;

    flareParticles.minLifeTime = 10.0;
    flareParticles.maxLifeTime = 10.0;

    // Emission rate
    surfaceParticles.emitRate = 200 ;
    flareParticles.emitRate = 1 ;

    // Blend mode : BLENDMODE_ONEONE, BLENDMODE_STANDARD, or BLENDMODE_ADD
    surfaceParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
    flareParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;


    // Set the gravity of all particles
    surfaceParticles.gravity = new BABYLON.Vector3(0, 0, 0);
    flareParticles.gravity = new BABYLON.Vector3(0, 0, 0);


    // Angular speed, in radians
    surfaceParticles.minAngularSpeed = -0.4;
    surfaceParticles.maxAngularSpeed = 0.4;

    flareParticles.minAngularSpeed = 0.0;
    flareParticles.maxAngularSpeed = 0.0;

    // Speed
    surfaceParticles.minEmitPower = 0;
    surfaceParticles.maxEmitPower = 0;
    surfaceParticles.updateSpeed = 0.005;

    flareParticles.minEmitPower = 0.001;
    flareParticles.maxEmitPower = 0.01;

    // coronaParticles.minEmitPower = 0.0;
    // coronaParticles.maxEmitPower = 0.0;

    // No billboard
    surfaceParticles.isBillboardBased = false;
    flareParticles.isBillboardBased = true;


    // Render Order
    flareParticles.renderingGroupId = 2;
    surfaceParticles.renderingGroupId = 3;
    coreSphere.renderingGroupId = 3;

    // Ensure depth write is enabled for particles to be occluded by meshes
    surfaceParticles.disableDepthWrite = false;
    flareParticles.disableDepthWrite = false;

    // Set transparency using materials for a more natural look
    var surfaceMaterial = new BABYLON.StandardMaterial("surfaceMaterial", scene);
    surfaceMaterial.alpha = 0.7; // Adjust opacity as needed
    surfaceParticles.material = surfaceMaterial;

    var flareMaterial = new BABYLON.StandardMaterial("flareMaterial", scene), sphereEmitterRadius;
    flareMaterial.alpha = 1.0; // Adjust opacity as needed
    flareParticles.material = flareMaterial;

// Optionally, animate the material alpha for a fading effect:
    scene.registerBeforeRender(function () {
      surfaceMaterial.alpha -= 0.005; // Adjust fade rate as needed
      flareMaterial.alpha -= 0.01; // Adjust fade rate as needed
    });


    // Start the particle system
    surfaceParticles.start();
    flareParticles.start();
   // coronaParticles.start();
  //  starsParticles.start();

    /*
    Clouds/varutha
     */

    // var fountain = BABYLON.Mesh.CreateBox("foutain", .01, scene);
    // fountain.visibility = 0;
    // fountain.position = new BABYLON.Vector3(0, 0, -50);
    //
    // // Create a particle system
    // var particleSystem;
    // //var useGPUVersion = false;
    //
    // var fogTexture = new BABYLON.Texture("https://raw.githubusercontent.com/aWeirdo/Babylon.js/master/smoke_15.png", scene);
    //
    //
    // var createNewSystem = function() {
    //   if (particleSystem) {
    //     particleSystem.dispose();
    //   }
    //
    //   // if (useGPUVersion && BABYLON.GPUParticleSystem.IsSupported) {
    //   //   particleSystem = new BABYLON.GPUParticleSystem("particles", { capacity: 50000 }, scene);
    //   //   particleSystem.activeParticleCount = 15000;
    //   //   particleSystem.manualEmitCount = particleSystem.activeParticleCount;
    //   //   particleSystem.minEmitBox = new BABYLON.Vector3(-50, 2, -50); // Starting all from
    //   //   particleSystem.maxEmitBox = new BABYLON.Vector3(50, 2, 50); // To..
    //   //
    //   // } else {
    //     particleSystem = new BABYLON.ParticleSystem("particles", 2500 , scene);
    //     particleSystem.manualEmitCount = particleSystem.getCapacity();
    //     particleSystem.minEmitBox = new BABYLON.Vector3(-150, -100, -100); // Starting all from
    //     particleSystem.maxEmitBox = new BABYLON.Vector3(150, 100, 100); // To...
    //  // }
    //
    //
    //   particleSystem.particleTexture = fogTexture.clone();
    //   particleSystem.emitter = fountain;
    //
    //   particleSystem.color1 = new BABYLON.Color4(0.8, 0.8, 0.8, 0.1);
    //   particleSystem.color2 = new BABYLON.Color4(.95, .95, .95, 0.15);
    //   particleSystem.colorDead = new BABYLON.Color4(0.9, 0.9, 0.9, 0.1);
    //   particleSystem.minSize = 20;
    //   particleSystem.maxSize = 30;
    //   particleSystem.minLifeTime = Number.MAX_SAFE_INTEGER;
    //   particleSystem.emitRate = 50000;
    //   particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;
    //   particleSystem.gravity = new BABYLON.Vector3(0, 0, 0);
    //   particleSystem.direction1 = new BABYLON.Vector3(0, 0, 0);
    //   particleSystem.direction2 = new BABYLON.Vector3(0, 0, 0);
    //   particleSystem.minAngularSpeed = -2;
    //   particleSystem.maxAngularSpeed = 2;
    //   particleSystem.minEmitPower = .5;
    //   particleSystem.maxEmitPower = 1;
    //   particleSystem.updateSpeed = 0.005;
    //
    //   particleSystem.start();
    // }
    //
    // createNewSystem();

/*
User
  function createNewParticleSystem(scene, fountainPosition = new BABYLON.Vector3(0, 0, -50),
                                   emitBoxSize = {min: new BABYLON.Vector3(-150, -100, -100),
                                                  max: new BABYLON.Vector3(150, 100, 200)},
                                   particleSize = {min: 20, max: 30},
                                   fogTextureUrl =
                                           "https://raw.githubusercontent.com/aWeirdo/Babylon.js/master/
 */
    const varutha_fog = {position: new BABYLON.Vector3(0, -20, 0), sphereEmitterRadius: 130}
    const sleeping_beauty_fog = {sphereEmitterRadius: 80,
      particleColors: {color1: "#670f0f", color2: "#561313", colorDead: "#6c2424"},
      position: new BABYLON.Vector3(200, 100, 150)}


    var varutha_fog_system = createNewSphericalParticleSystem(scene, varutha_fog);


    console.log("particleColors before", JSON.stringify(sleeping_beauty_fog.particleColors));
    var sleeping_beauty_fog_system = createNewSphericalParticleSystem(scene, sleeping_beauty_fog);
    console.log("particleColors after", JSON.stringify(sleeping_beauty_fog.particleColors));



        function restartParticleSystem(particleSystem, settings, scene) {
      // Dispose of the current particle system if it exists
      if (particleSystem && particleSystem.dispose) {
        particleSystem.dispose();
      }
     // console.log("Restarting particle system ...");
      // Recreate the particle system and return the new instance
      return createNewSphericalParticleSystem(scene, settings);
    }

    // Restart the first particle system every 3 minutes
    setInterval(() => {
      varutha_fog_system = restartParticleSystem(varutha_fog_system,varutha_fog, scene);
    }, 180000);

// Restart the second particle system every 3 minutes, on a different schedule if desired
    setInterval(() => {
    //  console.log("Scene sleeping beauty", scene);
    //   console.log("Sleeping beauty fog system is restarting");
      const sleeping_beauty_fog = {sphereEmitterRadius: 80,
        particleColors: {color1: "#670f0f", color2: "#561313", colorDead: "#6c2424"},
        position: new BABYLON.Vector3(200, 100, 150)}
      sleeping_beauty_fog_system = restartParticleSystem(sleeping_beauty_fog_system,sleeping_beauty_fog, scene);
    }, 180000);

    setInterval(() => {
      var particleColors = {color1: "#eeeeee", color2: "#cfcfff", colorDead: "#e5e5e5"}
      createParticleSystemAtRandomPosition(varutha_fog.position, varutha_fog.sphereEmitterRadius, particleColors, "sparks", scene);
    }, 1500);

    setInterval(() => {
           createParticleSystemAtRandomPosition(sleeping_beauty_fog.position, sleeping_beauty_fog.sphereEmitterRadius, sleeping_beauty_fog.particleColors, "sparks1", scene);
    }, 2500);







// Smaller systems emerging close to the central one for added complexity
//     createNewParticleSystem(scene, new BABYLON.Vector3(-150, -100, -100),
//             500,
//             {min: new BABYLON.Vector3(-50, -30, -30), max: new BABYLON.Vector3(50, 30, 60)},
//             {min: 10, max: 20});










      // edgeList.push([scene.getMeshByName("varutha_ship") ,scene.getMeshByName("natural_order")]);
      // edgeList.push([scene.getMeshByName("varutha_ship") ,scene.getMeshByName("pirate_outpost")]);
      // edgeList.push([scene.getMeshByName("varutha_ship") ,scene.getMeshByName("pirate_base")]);
      // edgeList.push([scene.getMeshByName("varutha_ship") ,scene.getMeshByName("sleeping_beauty")]);
      // edgeList.push([scene.getMeshByName("varutha_ship") ,scene.getMeshByName("metal_crusher_nest")]);
      // edgeList.push([scene.getMeshByName("bumblebee") ,scene.getMeshByName("pirate_outpost")]);
      // edgeList.push([scene.getMeshByName("pirate_outpost") ,scene.getMeshByName("pirate_base")]);







      // Now you can safely create your dashed lines
      //(edgeList, scene, thickness, dashSize, gapSize, bufferDistance)
     // createDashedCylinderLines(edgeList, scene, 5, 12,6 , 20);

      // // Call the callback function with the scene and the loaded meshList
       // onAssetsLoaded(scene);

    assetsManager.onFinish = function (tasks) {

      tasks.forEach(function (task) {
        // Assuming these are mesh tasks, add them to the meshList
        // Adjust this logic based on the type of tasks and your requirements
        if (task.loadedMeshes) {
          meshList.push(task.loadedMeshes[0]);
        }
      });

      setupMeshFunctionality(meshList, scene.activeCamera);
      addInfoTolocations(scene);

      console.log("edge list: ", edgeList);

      const varutha_natural_edge =[scene.getMeshByName("varutha_ship") ,scene.getMeshByName("natural_order")];
      const varutha_pirate_outpost_edge =[scene.getMeshByName("varutha_ship") ,scene.getMeshByName("pirate_outpost")];
      const varutha_pirate_base_edge =[scene.getMeshByName("varutha_ship") ,scene.getMeshByName("pirate_base")];
      const varutha_sleeping_beauty_edge =[scene.getMeshByName("varutha_ship") ,scene.getMeshByName("sleeping_beauty")];
      const varutha_metal_crusher_nest_edge =[scene.getMeshByName("varutha_ship") ,scene.getMeshByName("metal_crusher_nest")];
      const bumblebee_pirate_outpost_edge =[scene.getMeshByName("bumblebee") ,scene.getMeshByName("pirate_outpost")];
      const pirate_outpost_pirate_base_edge =[scene.getMeshByName("pirate_outpost") ,scene.getMeshByName("pirate_base")];
      const pirate_outpost_metal_crusher_nest_edge =[scene.getMeshByName("pirate_outpost") ,scene.getMeshByName("metal_crusher_nest")];
      const naturalorder_metal_crusher_nest_edge =[scene.getMeshByName("natural_order") ,scene.getMeshByName("metal_crusher_nest")];
      const piratebase_sleepingbeauty_edge =[scene.getMeshByName("pirate_base") ,scene.getMeshByName("sleeping_beauty")];
      const sleepingbeauty_naturalorder_edge =[scene.getMeshByName("sleeping_beauty") ,scene.getMeshByName("natural_order")];
      const bumblebee_damians_ship_edge =[scene.getMeshByName("bumblebee") ,scene.getMeshByName("damians_ship")];
      const damians_ship_pirate_outpost_edge =[scene.getMeshByName("damians_ship") ,scene.getMeshByName("pirate_outpost")];

      //(edgeList, scene, thickness, dashSize, gapSize, bufferDistance)

      var thickness = 1;
      var dashSize = 3;
      var gapSize = 4;

      createDashedCylinderLine(varutha_natural_edge,scene, thickness, dashSize , gapSize, 50, 80);
      createDashedCylinderLine(varutha_pirate_outpost_edge,scene, thickness, dashSize , gapSize, 60, 10);
      createDashedCylinderLine(varutha_pirate_base_edge,scene, thickness, dashSize , gapSize, 70, 60);
      createDashedCylinderLine(varutha_sleeping_beauty_edge,scene, thickness, dashSize , gapSize, 50,10);
      createDashedCylinderLine(varutha_metal_crusher_nest_edge,scene, thickness, dashSize , gapSize, 50, 50);
      createDashedCylinderLine(bumblebee_pirate_outpost_edge, scene, thickness, dashSize , gapSize, 10, 10 );
      createDashedCylinderLine(pirate_outpost_pirate_base_edge,scene, thickness, dashSize , gapSize, 10, 10);
      createDashedCylinderLine(pirate_outpost_metal_crusher_nest_edge,scene, thickness, dashSize , gapSize, 10, 50);
      createDashedCylinderLine(naturalorder_metal_crusher_nest_edge,scene, thickness, dashSize , gapSize, 50, 50);
      createDashedCylinderLine(piratebase_sleepingbeauty_edge,scene, thickness, dashSize , gapSize, 50, 10);
      createDashedCylinderLine(sleepingbeauty_naturalorder_edge,scene, thickness, dashSize , gapSize, 10, 50);
      createDashedCylinderLine(bumblebee_damians_ship_edge,scene, thickness, dashSize , gapSize, 10, 10);
      createDashedCylinderLine(damians_ship_pirate_outpost_edge,scene, thickness, dashSize , gapSize, 10, 10);


      console.log("All models loaded");
        let position = new BABYLON.Vector3(50, 50, 50); // Placeholder position
         let position1 = new BABYLON.Vector3(100, 100, 100); // Placeholder position
        let position2 = new BABYLON.Vector3(150, 150, 150); // Placeholder position
         let position3 = new BABYLON.Vector3(200, 200, 200); // Placeholder position
         let position4 = new BABYLON.Vector3(250, 250, 250); // Placeholder position

      createInstanceFromModel("debris1", position);
      createInstanceFromModel("debris1", position1);
        createInstanceFromModel("debris1", position2);
        createInstanceFromModel("debris1", position3);
        createInstanceFromModel("debris1", position4);
      };

    assetsManager.load();




    //  scene.fogEnabled = true;
    //  scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;
    //  scene.fogStart = 200.0; // The distance from the camera where fog starts
    //  scene.fogEnd = 2500.0; // The distance from the camera where fog fully obscures objects
    //  scene.fogColor = new BABYLON.Color3(0.1, 0.1, 0.1); // Adjust the color to match the scene's background/skybox
    // scene.ambientColor = new BABYLON.Color3(0.3, 0.3, 0.3)

    // Enable depth rendering for depth of field effect
    new BABYLON.AxesViewer(scene, 5);
    const axes = new BABYLON.Debug.AxesViewer(scene, 5)
    // scene.debugLayer.show();
    //return scene and meshList
    return scene;
  };

  let scene = createScene(function (loadedScene) {

    loadedScene.executeWhenReady(function () {
      // This code will be executed once the scene is fully ready

      console.log("Scene loaded");


    });
  })


  scene.collisionsEnabled = true;

  engine.runRenderLoop(function () {
    scene.render();
  });

  // Resize
  window.addEventListener("resize", function() {
    engine.resize();
  });

  // Function to toggle mesh visibility
  function toggleMeshVisibility(meshList) {
    console.log("meshList: ", meshList);
    globalVisibility = !globalVisibility; // Toggle the global visibility state
    meshList.forEach(mesh => {
      mesh.setEnabled(globalVisibility); // Apply the current state to each mesh
    });
  }
  let globalVisibility = true;
  // List of meshes you want to control
  let lines  = [];

  // Setup the button to call the toggle function
  document.getElementById('visibilityToggle').addEventListener('click', () => toggleMeshVisibility(lines));


  /*
  All following functions are associated with setting up the map. E.g., creating the camera,
   */



  // Create the Universal Camera
  function createUniversalCamera(scene, canvas) {
    let initialCameraPosition = new BABYLON.Vector3(0, 100, -750);
    universalCamera = new BABYLON.UniversalCamera("UniversalCamera", initialCameraPosition, scene);
    universalCamera.attachControl(canvas, true);
    universalCamera.keysUp.push(87); // W
    universalCamera.keysDown.push(83); // S
    universalCamera.keysLeft.push(65); // A
    universalCamera.keysRight.push(68); // D
    universalCamera.speed = 5;
    universalCamera.angularSensitivity = 1500;
    universalCamera.checkCollisions = true;
    universalCamera.ellipsoid = new BABYLON.Vector3(5, 5, 5);
    universalCamera.maxZ = 15000;

    let downwardTiltAngle = 15 * (Math.PI / 180); // Downward tilt of 5 degrees converted to radians
   // let rightTiltAngle = 10 * (Math.PI / 180); // Right tilt of 5 degrees converted to radians

    universalCamera.rotation.x = downwardTiltAngle; // Apply the downward tilt
 //   universalCamera.rotation.z = rightTiltAngle; // Apply the right tilt


  }

  // Create the ArcRotate Camera
  function createArcRotateCamera(scene, canvas) {
    let target = BABYLON.Vector3.Zero(); // Assuming you want to look at the origin
    arcRotateCamera = new BABYLON.ArcRotateCamera("ArcRotateCamera", -Math.PI / 2, Math.PI / 2.5, 10, target, scene);
    arcRotateCamera.checkCollisions = true;
    arcRotateCamera.ellipsoid = new BABYLON.Vector3(5, 5, 5);
    arcRotateCamera.attachControl(canvas, true);
    arcRotateCamera.maxZ = 15000;

    // var lensEffect = new BABYLON.LensRenderingPipeline('lens', {
    //   edge_blur: 0.3,
    //   chromatic_aberration: 0.8,
    //   distortion: 0.8,
    //   dof_focus_distance: 50,
    //   dof_aperture: 6.0,			// set this very high for tilt-shift effect
    //   grain_amount: 1.0,
    //   dof_pentagon: true,
    //   dof_gain: 1.0,
    //   dof_threshold: 1.0,
    //   dof_darken: 0.25
    // }, scene, 1.0, arcRotateCamera);

    // Optional: Adjust properties similar to the universal camera if needed
  }


  function switchCamera(scene) {
    console.log("Current active camera: ", scene.activeCamera.name);
    if (scene.activeCamera === universalCamera) {
      scene.activeCamera = arcRotateCamera;
      arcRotateCamera.position = universalCamera.position;
      arcRotateCamera.attachControl(scene.getEngine().getRenderingCanvas(), true);
    } else {
      scene.activeCamera = universalCamera;
      universalCamera.position = arcRotateCamera.position;
      universalCamera.setTarget(lastSelectedMesh.position)
      universalCamera.attachControl(scene.getEngine().getRenderingCanvas(), true);
    }



  }


  function createSkyBox(scene, assetsManager) {
    var cubeTextureTask = assetsManager.addCubeTextureTask("skyboxTask", "http://localhost:8080/skybox/nebula_space_corrected", [
      "_right11.jpg",
      "_top31.jpg",
      "_front51.jpg",
      "_left21.jpg",
      "_bottom41.jpg",
      "_back61.jpg"
    ]);

    cubeTextureTask.onSuccess = function (task) {

      // Define the size of the boundary
      var size = 3000;
      var thickness = 10; // Thickness of the walls

      let skybox = BABYLON.Mesh.CreateBox("skyBox", size, scene);
      let skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
      skyboxMaterial.backFaceCulling = false;
      skyboxMaterial.reflectionTexture = cubeTextureTask.texture;
      skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
      skyboxMaterial.disableLighting = true;
      skybox.material = skyboxMaterial;
      skybox.isPickable = false;



      // Function to create a wall
      function createWall(name, position, rotation, size) {
        var wall = BABYLON.MeshBuilder.CreateBox(name, {width: size.width, height: size.height, depth: thickness}, scene);
        wall.position = position;
        wall.position = position;
        wall.rotation = rotation;
        wall.isVisible = false;
        wall.checkCollisions = true;
      }

      // Wall dimensions
      var wallHeight = size;
      var wallWidth = size;

      // Positions and rotations for the walls
      var positions = [
        new BABYLON.Vector3(0, 0, -size / 2), // Front
        new BABYLON.Vector3(0, 0, size / 2), // Back
        new BABYLON.Vector3(-size / 2, 0, 0), // Left
        new BABYLON.Vector3(size / 2, 0, 0), // Right
        new BABYLON.Vector3(0, -size / 2, 0), // Bottom
        new BABYLON.Vector3(0, size / 2, 0) // Top
      ];

      var rotations = [
        new BABYLON.Vector3(0, 0, 0), // Front
        new BABYLON.Vector3(0, Math.PI, 0), // Back
        new BABYLON.Vector3(0, Math.PI / 2, 0), // Left
        new BABYLON.Vector3(0, -Math.PI / 2, 0), // Right
        new BABYLON.Vector3(Math.PI / 2, 0, 0), // Bottom
        new BABYLON.Vector3(-Math.PI / 2, 0, 0) // Top
      ];

      skybox.infiniteDistance = true;

      // Create the walls
      for (var i = 0; i < positions.length; i++) {
        createWall("wall" + i, positions[i], rotations[i], {width: wallWidth, height: wallHeight});
      }
    }
  }

  function createSphericalSkyBox(scene, assetsManager) {
    var sphereTextureTask = assetsManager.addTextureTask("skyboxSphereTask", "http://localhost:8080/skybox/purple_nebula.dds");

    sphereTextureTask.onSuccess = function (task) {

      // Define the radius of the skybox sphere
      var radius = 1250;

      let skybox = BABYLON.Mesh.CreateSphere("skyBox", 32, radius * 2, scene);
      let skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
      skyboxMaterial.backFaceCulling = false;
      skyboxMaterial.reflectionTexture = sphereTextureTask.texture;
      skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // Assuming equirectangular texture
      skyboxMaterial.disableLighting = true;
      skybox.material = skyboxMaterial;
      skybox.infiniteDistance = true;
      skybox.isPickable = false;

      // Function to create a spherical wall
      function createSphericalWall(name, radius) {
        var wall = BABYLON.Mesh.CreateSphere(name, 32, radius * 2, scene);
        wall.isVisible = false;
        wall.isPickable = false;
        wall.checkCollisions = true;
      }

      // Create a spherical wall with the same radius as the skybox
      createSphericalWall("sphericalWall", radius);
    }
  }

  function getLongestSideOfMesh(mesh) {
    var boundingBox = mesh.getBoundingInfo().boundingBox;
    var minPoint = boundingBox.minimumWorld;
    var maxPoint = boundingBox.maximumWorld;

    // Calculate distances along each axis
    var distanceX = Math.abs(maxPoint.x - minPoint.x);
    var distanceY = Math.abs(maxPoint.y - minPoint.y);
    var distanceZ = Math.abs(maxPoint.z - minPoint.z);

    // Determine the longest side
    var longestSideLength = Math.max(distanceX, distanceY, distanceZ);

    // Return the length of the longest side and its axis
    if (longestSideLength === distanceX) {
      return { length: longestSideLength, axis: 'X' };
    } else if (longestSideLength === distanceY) {
      return { length: longestSideLength, axis: 'Y' };
    } else {
      return { length: longestSideLength, axis: 'Z' };
    }
  }

  //Zoom in on mesh upon click
  function applyZoom(mesh,camera,target) {
    if (!mesh.actionManager) {
      mesh.actionManager = new BABYLON.ActionManager(mesh.getScene());
    }

    if (!target){
      target = mesh;
    }

    console.log("Applied zoom to camera", camera.name);

    mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function (event) {

                      if (scene.activeCamera === universalCamera) {
                        switchCamera(scene);
                      }


                      var pickedMesh = event.meshUnderPointer;
                      if (pickedMesh === mesh) {
                        lastSelectedMesh = mesh;
                        var angle =  Math.PI / 4; // 225 degrees
                        console.log("zoom_mesh_name", mesh.name);
                        var distance = getLongestSideOfMesh(target).length * 3; // distance from the mesh

                        // Calculate the new camera position
                        var camX = target.getAbsolutePosition().x - distance * Math.cos(angle);
                        var camY = target.getAbsolutePosition().y + distance * Math.sin(angle);
                        var camZ = target.getAbsolutePosition().z - distance * Math.sin(angle);

                        var camEndPos = new BABYLON.Vector3(camX, camY, camZ);

                        // Calculate the new target position
                        /*
                        var targetX = mesh.getAbsolutePosition().x;
                        var targetY = mesh.getAbsolutePosition().y;
                        var targetZ = mesh.getAbsolutePosition().z;

                        var targetEndPos = new BABYLON.Vector3(targetX, targetY, targetZ);
                         */

                        var targetEndPos = target.getAbsolutePosition();


                        var speed = 45;
                        var ease = new BABYLON.CubicEase();

                        ease.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);


                        // var animationsCompleted = 0; // Counter to track completed animations
                        //
                        // // Function to increment counter and check if both animations are complete
                        // var onAnimationEnd = function () {
                        //   animationsCompleted += 1;
                        //   if (animationsCompleted === 2) { // Ensure both animations have completed
                        //     fogify(scene, 0.30, 50.0, 25); // Adjust the rate as needed
                        //   }
                        // };

                       //  firstAnimationDone = false;
                       //  secondAnimationDone = false;
                       //
                       //  var onAnimationEnd1 = function () {
                       //    console.log("First animation done");
                       //    firstAnimationDone = true;
                       //      if (firstAnimationDone && secondAnimationDone) {
                       //       switchCamera(scene);
                       //      }
                       // };
                       //
                       //  var onAnimationEnd2 = function () {
                       //    console.log("Second animation done")
                       //    secondAnimationDone = true;
                       //    if (firstAnimationDone && secondAnimationDone) {
                       //      switchCamera(scene);
                       //    }
                       //  };


                        BABYLON.Animation.CreateAndStartAnimation(
                                'at4',
                                scene.activeCamera,
                                'position',
                                speed,
                                120,
                                scene.activeCamera.position,
                                camEndPos,
                                0,
                                ease
                                // ,
                                // onAnimationEnd1
                        );

                        BABYLON.Animation.CreateAndStartAnimation(
                                'at5',
                                scene.activeCamera,
                                'target',
                                speed,
                                120,
                                scene.activeCamera.target,
                                targetEndPos,
                                0,
                                ease
                                // ,
                                // onAnimationEnd2
                        );
                      }
                    }
            )
    );




    console.log("Applied Zoom to mesh: " + mesh.name);
  }

  /**
   * Gradually adjusts fog settings towards target values.
   * @param {BABYLON.Scene} scene - The Babylon.js scene to apply fog.
   * @param {number} targetFogStart - The target distance from the camera where fog starts.
   * @param {number} targetFogEnd - The target distance from the camera where fog fully obscures objects.
   * @param {number} rate - The rate of change for fog parameters per frame.
   */
  function fogify(scene, targetFogStart, targetFogEnd, rate) {
    scene.fogEnabled = true;

    // Ensure the fog mode is set (it could be any of the available modes)
    scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;

    // This observable will run every frame before rendering
    scene.onBeforeRenderObservable.add(() => {
      // Gradually adjust fogStart towards the target value
      if (scene.fogStart < targetFogStart) {
        scene.fogStart = Math.min(scene.fogStart + rate, targetFogStart);
      } else if (scene.fogStart > targetFogStart) {
        scene.fogStart = Math.max(scene.fogStart - rate, targetFogStart);
      }

      // Gradually adjust fogEnd towards the target value
      if (scene.fogEnd < targetFogEnd) {
        scene.fogEnd = Math.min(scene.fogEnd + rate, targetFogEnd);
      } else if (scene.fogEnd > targetFogEnd) {
        scene.fogEnd = Math.max(scene.fogEnd - rate, targetFogEnd);
      }
    });
  }


  function createSparkleSystem(name, color, position, scene) {
    // console.log("Creating sparkle system at position", position);
    // console.log("Name of the system", name);
    // console.log("Scene", scene);
    var sparkleSystem = new BABYLON.ParticleSystem("sparkle", 2000, scene);

    // Texture of each particle
    sparkleSystem.particleTexture = new BABYLON.Texture("http://localhost:8080/assets/star_particle.jpg", scene);


    sparkleSystem.createSphereEmitter(1); // Radius of the sphere

    sparkleSystem.emitter = position; // the starting position

    // Colors of all particles
    color.color1 = new BABYLON.Color3.FromHexString("#d7d7d7");
    color.color2 = new BABYLON.Color3.FromHexString("#ffffff");
    color.colorDead = new BABYLON.Color3.FromHexString("#b6b4f8");


    // Configuration of particle sizes and lifetimes
    sparkleSystem.minSize = 2;
    sparkleSystem.maxSize = 7;
    sparkleSystem.minLifeTime = 0.1;
    sparkleSystem.maxLifeTime = .2;

    // Emission settings
    sparkleSystem.manualEmitCount = 4; // Number of particles emitted in one burst
    sparkleSystem.disposeOnStop = true; // Automatically dispose the system when it stops
    sparkleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

    // Angular speed and emit power settings
  //  sparkleSystem.minAngularSpeed = 20;
    //sparkleSystem.maxAngularSpeed = 30;
    sparkleSystem.minEmitPower = 1;
    sparkleSystem.maxEmitPower = 5;
    sparkleSystem.updateSpeed = 0.005;

    // Starting the particle system
    sparkleSystem.start();
  }

  function getRandomPositionInsideSphere(center, radius) {
    let u = Math.random();
    let v = Math.random();
    let theta = u * 2.0 * Math.PI;
    let phi = Math.acos(2.0 * v - 1.0);
    let r = Math.cbrt(Math.random()) * radius;
    let sinTheta = Math.sin(theta);
    let cosTheta = Math.cos(theta);
    let sinPhi = Math.sin(phi);
    let cosPhi = Math.cos(phi);
    let x = r * sinPhi * cosTheta;
    let y = r * sinPhi * sinTheta;
    let z = r * cosPhi;
    return new BABYLON.Vector3(x + center.x, y + center.y, z + center.z);
  }

  function createParticleSystemAtRandomPosition(center, radius, color, name, scene) {
    // Get a random position within the specified sphere
    let randomPosition = getRandomPositionInsideSphere(center, radius);

    // console.log("Creating particle system at random position: ", randomPosition.toString());
    // // Create the particle system at the random position
    // console.log("Name: ", name);
    // console.log("Scene: ", scene);
    createSparkleSystem(name, color, randomPosition, scene);
  }

  function createNewSphericalParticleSystem(scene, {position = new BABYLON.Vector3(0, 0, -50),
                                   particleNumber = 800,
                                   sphereEmitterRadius = 1000, // Original value at 250 TODO see if we can spread particles further somehow
                                   particleSize = {min: 60, max: 100},
                                   particleColors = {color1: "#eeeeee", color2: "#cfcfff", colorDead: "#e5e5e5"},
                                    fogTextureUrl = "http://localhost:8080/assets/water3.png" }) {
    // fogTextureUrl = "https://raw.githubusercontent.com/aWeirdo/Babylon.js/master/smoke_15.png"}) {

    // console.log("Creating new spherical particle system")
    // console.log("Position: ", position)
    // console.log("Radius: ", sphereEmitterRadius)

    // // Custom shader for particles
    // BABYLON.Effect.ShadersStore["myParticleFragmentShader"] =
    //         "#ifdef GL_ES\n" +
    //         "precision highp float;\n" +
    //         "#endif\n" +
    //         "varying vec2 vUV;\n" +
    //         "varying vec4 vColor;\n" +
    //         "uniform sampler2D diffuseSampler;\n" +
    //         "uniform float time;\n" +
    //         "void main(void) {\n" +
    //         "vec2 position = vUV;\n" +
    //         "float color = 0.0;\n" +
    //         "vec2 center = vec2(0.5, 0.5);\n" +
    //         "color = sin(distance(position, center) * 10.0 + time * vColor.g);\n" +
    //         "vec4 baseColor = texture2D(diffuseSampler, vUV);\n" +
    //         "gl_FragColor = baseColor * vColor * vec4(vec3(color, color, color), 1.0);\n" +
    //         "}\n";
    //
    // // Create an effect for particles using the custom shader
    // var effect = scene.getEngine().createEffectForParticles("myParticle", ["time"]);


    var particleSystem = new BABYLON.ParticleSystem("particles", particleNumber, scene);
    particleSystem.manualEmitCount = particleSystem.getCapacity();

    var fogTexture = new BABYLON.Texture(fogTextureUrl, scene);
    particleSystem.particleTexture = fogTexture.clone();


    // Setting the particleEmitterType to a SphereParticleEmitter
    var sphereEmitter = new BABYLON.SphereParticleEmitter();
    sphereEmitter.radius = sphereEmitterRadius; // Setting the radius of the sphere
    sphereEmitter.radiusRange = 1;
    particleSystem.emitter = position;
    particleSystem.particleEmitterType = sphereEmitter;

    let color1x = new BABYLON.Color3.FromHexString(particleColors.color1);
    let color2x = new BABYLON.Color3.FromHexString(particleColors.color2);
    let colorDeadx = new BABYLON.Color3.FromHexString(particleColors.colorDead);

    particleSystem.color1 = new BABYLON.Color4(color1x.r,color1x.g, color1x.b, 0.3);
    particleSystem.color2 = new BABYLON.Color4(color2x.r, color2x.g, color2x.b, 0.2);
    particleSystem.colorDead = new BABYLON.Color4(colorDeadx.r, colorDeadx.g, colorDeadx.b, 0.1);

    particleSystem.minSize = particleSize.min;
    particleSystem.maxSize = particleSize.max;
    particleSystem.minLifeTime = Number.MAX_SAFE_INTEGER;
    particleSystem.emitRate = 50000;
    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
    particleSystem.gravity = new BABYLON.Vector3(0, 0, 0);
    // Directional properties are still applicable, but the sphere emitter provides a natural spread
    particleSystem.direction1 = new BABYLON.Vector3(0, 0, 0);
    particleSystem.direction2 = new BABYLON.Vector3(0, 0, 0);
 //   particleSystem.minAngularSpeed = -2;
  //  particleSystem.maxAngularSpeed = 2;
    particleSystem.minEmitPower = .3;
    particleSystem.maxEmitPower = .9;
    particleSystem.updateSpeed = 0.005;

//     // Create sub emitter
//     var subEmitter = new BABYLON.SubEmitter(createSystem(new BABYLON.Color4(1, 1, 1), 1,"sparks", scene));
// // Have the sub emitter spawn the particle system when the particle dies
//     subEmitter.type = BABYLON.SubEmitterType.ATTACHED;
//
//     particleSystem.subEmitters = [subEmitter];

    particleSystem.start();
    return particleSystem; // Optionally return the particle system for further manipulation
  }



  function createNewParticleSystem(scene, fountainPosition = new BABYLON.Vector3(0, 0, -50),
                                   particleNumber = 2500,
                                   emitBoxSize = {min: new BABYLON.Vector3(-150, -100, -100),
                                                  max: new BABYLON.Vector3(150, 100, 200)},
                                   particleSize = {min: 20, max: 30},
                                   fogTextureUrl =
                                           "https://raw.githubusercontent.com/aWeirdo/Babylon.js/master/smoke_15.png") {
    var fountain = BABYLON.Mesh.CreateBox("fountain", .01, scene);
    fountain.visibility = 0;
    fountain.position = fountainPosition;

    var particleSystem = new BABYLON.ParticleSystem("particles", particleNumber, scene);
    particleSystem.manualEmitCount = particleSystem.getCapacity();
    particleSystem.minEmitBox = emitBoxSize.min; // Starting all from
    particleSystem.maxEmitBox = emitBoxSize.max; // To...

    var fogTexture = new BABYLON.Texture(fogTextureUrl, scene);
    particleSystem.particleTexture = fogTexture.clone();
    particleSystem.emitter = fountain;

    let color1 = new BABYLON.Color3.FromHexString("#cccccc");
    let color2 = new BABYLON.Color3.FromHexString("#f2f2f2");
    let colorDead = new BABYLON.Color3.FromHexString("#e5e5e5");

    particleSystem.color1 = new BABYLON.Color4(color1.r,color1.g, color1.b, 0.1);
    particleSystem.color2 = new BABYLON.Color4(color2.r, color2.g, color2.b, 0.15);
    particleSystem.colorDead = new BABYLON.Color4(colorDead.r, colorDead.g, colorDead.b, 0.1);

    //particleSystem.color2 = new BABYLON.Color4(.95, .95, .95, 0.15);
    //particleSystem.colorDead = new BABYLON.Color4(0.9, 0.9, 0.9, 0.1);
    particleSystem.minSize = particleSize.min;
    particleSystem.maxSize = particleSize.max;
    particleSystem.minLifeTime = Number.MAX_SAFE_INTEGER;
    particleSystem.emitRate = 100000;
    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;
    particleSystem.gravity = new BABYLON.Vector3(0, 0, 0);
    particleSystem.direction1 = new BABYLON.Vector3(0, 0, 0);
    particleSystem.direction2 = new BABYLON.Vector3(0, 0, 0);
    particleSystem.minAngularSpeed = -2;
    particleSystem.maxAngularSpeed = 2;
    particleSystem.minEmitPower = .5;
    particleSystem.maxEmitPower = 1;
    particleSystem.updateSpeed = 0.005;

    particleSystem.start();
    return particleSystem; // Optionally return the particle system for further manipulation
  }



  // write a function that adds functionality to each mesh in a list
  function setupMeshFunctionality(meshList, camera) {
    meshList.forEach(function (mesh) {
      mesh.ignoreCameraMaxZ = true;
      if (mesh.getChildMeshes().length > 0) {
        const childMesh = mesh.getChildMeshes()[0];
        console.log(childMesh.name);
        for (let i = 0; i < mesh.getChildMeshes().length; i++) {
          applyZoom(mesh.getChildMeshes()[i], camera, childMesh);
        }
      } else {
        console.log(mesh.name);
        applyZoom(mesh,camera);
      }
    });
  }

  //Open modal frame with location information
  // Checking onPointerDown event, see console

  function addInfoTolocations(scene) {
    scene.onPointerDown = function (evt, pickResult) {
      setTimeout(function () {
        if (pickResult.hit) {
          console.log("pickResult.hit: " + pickResult.pickedMesh.name);
          const regex = /^(.*)(_primitive\d+)$/;
          var match = pickResult.pickedMesh.name.match(regex);
          var poi_name = pickResult.pickedMesh.name;
          if (match){
            poi_name = match[1];
          }


            if (meshContent[poi_name]) {
            console.log("In the list");
            toggleModal();
            console.log(meshContent.hasOwnProperty(poi_name)); // false if not in our object
            console.log(poi_name);
            console.log("Mesh: " + pickResult.pickedMesh.name + "; ID: " + meshContent[poi_name]);
            document.getElementById("modal-iframe").innerHTML = "<iframe src=\"http://localhost:49449/graveyard_of_ships/" +
                    meshContent[poi_name] +
                    "\" title=\"Modal\"frameborder=\"0\" style=" +
                    "height:100%;width:100%;position:absolute;top:0px;left:0px;right:0px;bottom:0px\"></iframe>"
          }
        }
      }, 1000);
    }
  }

  function createDashedCylinderLine(edge, scene, thickness, dashSize, gapSize, startBufferDistance = null, endBufferDistance = null) {

      console.log("Creating dashed line between: " + edge[0].name + " and " + edge[1].name);
      console.log("Original position of edge[0]: " + edge[0].position);
        console.log("Original position of edge[1]: " + edge[1].position);
      let startPointMesh = edge[0];
      let endPointMesh = edge[1];


    console.log("daughter position of edge[0]: " +startPointMesh.position);
    console.log("daughter position of edge[1]: " + endPointMesh.position);

      let startPoint = startPointMesh.position;
      let endPoint = endPointMesh.position;

      // Calculate or use provided buffer distances
      if (startBufferDistance === null) {
        startBufferDistance = getLongestSideOfMesh(startPointMesh).length / 2 + 30;
      }
      if (endBufferDistance === null) {
        endBufferDistance = getLongestSideOfMesh(endPointMesh).length / 2 + 30;
      }

      console.log("Start Buffer distance: " + startBufferDistance + ", End Buffer distance: " + endBufferDistance);

      let direction = endPoint.subtract(startPoint).normalize();
      let fullLength = endPoint.subtract(startPoint).length();

      // Adjust the start and end points by the individual buffer distances
      startPoint = startPoint.add(direction.scale(startBufferDistance));
      endPoint = endPoint.subtract(direction.scale(endBufferDistance));

      console.log("Start Point: " + startPoint + ", End Point: " + endPoint);

      let adjustedLength = endPoint.subtract(startPoint).length();
      let normalizedDirection = endPoint.subtract(startPoint).normalize();

      let numDashes = Math.floor(adjustedLength / (dashSize + gapSize));

      let dashedLine = new BABYLON.Mesh("dashedLine", scene);

      for (let i = 0; i < numDashes; i++) {
        let dashPosition = startPoint.add(normalizedDirection.scale(i * (dashSize + gapSize) + dashSize / 2));

        let dashCylinder = createCapsule(scene, dashSize, thickness);

        dashCylinder.position = dashPosition;

        // Calculate the rotation axis and angle
        let up = new BABYLON.Vector3(0, 1, 0); // Cylinder's default up direction
        let axis = BABYLON.Vector3.Cross(up, normalizedDirection).normalize();
        let angle = Math.acos(BABYLON.Vector3.Dot(up, normalizedDirection));

        // Apply the rotation
        dashCylinder.rotationQuaternion = BABYLON.Quaternion.RotationAxis(axis, angle);

        // Parent the dash cylinder to the dashed line
        dashCylinder.parent = dashedLine;

      }

    lines.push(dashedLine);
    }



  function createCapsule(scene, height, diameter) {
    var radius = diameter / 2;
    var cylinderHeight = height - diameter; // subtract the spherical caps from the cylinder height

    // Create cylinder
    var cylinder = BABYLON.MeshBuilder.CreateCylinder("cylinder", {height: cylinderHeight, diameter: diameter}, scene);

    // Create top and bottom spheres
    var topSphere = BABYLON.MeshBuilder.CreateSphere("topSphere", {diameter: diameter}, scene);
    topSphere.position.y = cylinderHeight / 2;

    var bottomSphere = BABYLON.MeshBuilder.CreateSphere("bottomSphere", {diameter: diameter}, scene);
    bottomSphere.position.y = -cylinderHeight / 2;

    // Merge all parts into one mesh
    var capsule = BABYLON.Mesh.MergeMeshes([cylinder, topSphere, bottomSphere], true, true, undefined, false, false);

    let material = new BABYLON.StandardMaterial("dashedLineMaterial", scene);
    material.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8); // Set color to white
    material.emissiveColor = new BABYLON.Color3(0.8, 0.8, 0.8);
    //material.disableLighting = true;
    capsule.material = material;
    //make capsule slightly transparent
    capsule.material.alpha = 1;
    capsule.outlineColor = new BABYLON.Color3(0, 0, 0);

    return capsule;
  }


</script>
</body>
</html>
